# Summarise posterior sampled point patterns 
# using pairwise distances

library(INLA)
library(inlabru)
library(rgeos)
library(sf)

# set ggplot theme
theme_set(theme_minimal())
set.seed(9701071)

#### Fitted model  ####
model_path = here::here("Analysis", "fitted_model.RDS")
fit = readRDS(model_path)

data_path = here::here("Data")
obs <- readRDS(here::here(data_path, "obs_extended_no_crs.RDS"))
study_area = readRDS(here::here(data_path, "study_area_extended_no_crs.RDS"))
samplers = readRDS(here::here(data_path, "samplers_extended_no_crs.RDS"))

# polygon samplers 
W = 58/1000
samplers_buffered = gBuffer(samplers, width = W, byid = TRUE)
mesh = readRDS(here::here(data_path, "mesh_extended_no_crs.RDS"))

### Generate posterior point patterns
n.pp = 100

# simulate intensities and detection functions
# each column of llam is a realisation of the log-intensity at each mesh node
post.sample = generate(fit,
                formula = ~ {c(
                  llam = grf_latent + Intercept_latent,
                  lsig = lsig_latent)
                },
                n.samples = n.pp)

llam = post.sample[1:mesh$n, ]
lsig.post = post.sample["lsig",]

# create distance bins and matrix to store counts
breaks = 0:12
counts = matrix(NA, nrow = n.pp, ncol = length(breaks)-1)

# detection functions
# Log half-normal
log_hn = function(distance, lsig){
  -0.5*(distance/exp(lsig))^2
}

# Half-normal
hn <- function(distance, lsig) exp(log_hn(distance, lsig))

# Need to create a new mesh just in the study area and
# project llam to this. Boundary was giving very large intensities
# when trying with full mesh and samplers argument

## Generated by meshbuilder()

## Build boundary information:
## (fmesher supports SpatialPolygons, but this app is not (yet) intelligent enough for that.)
boundary <- list(
  as.inla.mesh.segment(study_area),
  NULL)

## Build the mesh:
inner_mesh <- inla.mesh.2d(boundary=boundary,
                     max.edge=c(0.25, 0.61),
                     min.angle=c(30, 21),
                     max.n=c(48000, 16000), ## Safeguard against large meshes.
                     max.n.strict=c(128000, 128000), ## Don't build a huge mesh!
                     cutoff=0.024, ## Filter away adjacent points.
                     offset=c(0.1, 0.13)) ## Offset for extra boundaries, if needed.

A = inla.spde.make.A(mesh = mesh,
                     loc = inner_mesh$loc)

inner_llam = A %*% llam

# Note:  I think there is a way to use inner_mesh in the generate() 
# call above to avoid having to create A and project afterwards. 
# Have not tested this though.

# Warning:
# I was getting memory leaks in the loops, suspect it
# was an rgeos function and could not resolve it.

# Use sf functions to avoid rgeos
samplers_sf = st_as_sf(samplers)
samplers_buffered_sf = st_buffer(samplers_sf,
                                 dist = W)
samplers_sf$ID = 1:nrow(samplers_sf)
samplers_buffered_sf$ID = 1:nrow(samplers_sf)

for (i in 1:n.pp){

  cat("\nGenerating point pattern ", i, "\n")
  a.pp = sample.lgcp(mesh = inner_mesh,
                     loglambda = inner_llam[,i],
                     samplers = study_area)
  a.pp = a.pp[samplers_buffered,]   # detectable points
  a.lsig = lsig.post[i]

  cat("\nThinning point pattern ", i, "\n")
  a.pp = st_as_sf(a.pp)
  pp_det = st_join(a.pp,
                   samplers_buffered_sf[,"ID"])

  distances = rep(NA, nrow(pp_det))

  for (j in 1:nrow(pp_det)){
    pt = pp_det[j,]
    transect = subset(samplers_sf, ID == pt$ID)
    distances[j] = as.numeric(st_distance(pt, transect))
  }

  pdet = hn(distances, a.lsig)
  pp_det$distances = distances
  pp_det$pdet = pdet

  detected <- rbinom(nrow(pp_det), 1, pdet)
  a.obs <- subset(pp_det, as.logical(detected))

  # calculate pairwise distances
  a.ds = st_distance(a.obs, byid = TRUE)
  a.ds[upper.tri(a.ds, diag = TRUE)] = NA
  a.ds.vec = as.numeric(a.ds)
  a.ds.vec = a.ds.vec[!is.na(a.ds.vec)]
  counts[i,] = hist(a.ds.vec, breaks = breaks, plot = FALSE)$counts

  cat("\nFinished processing point pattern ", i, "\n")

  # memory leak?
  rm(a.ds, a.ds.vec, a.obs, a.lsig, a.pp)
  gc()
}

# pairwise distances for observed data
obs.ds = gDistance(obs, byid = TRUE)
obs.ds[upper.tri(obs.ds, diag = TRUE)] = NA
obs.ds.vec = as.numeric(obs.ds)
count.obs = hist(obs.ds.vec, breaks = breaks, plot = FALSE)$counts

# plot
png(filename = here::here("Figures", "post_pp_distances.png"),
    width = 7, height = 4, units = "in", res = 100)

boxplot(counts,
        xlab = "distance (km)",
        ylab = "count of pairwise distances",
        xaxt = "n",
        range = 0,
        col = "white")
points(1:(length(breaks)-1), count.obs, col = "red")
# xticks = floor(breaks[-1] - (breaks[2] - breaks[1])/2)
xticks = breaks[-1]
axis(1, at = 1:(length(breaks)-1), labels = xticks)
dev.off()
